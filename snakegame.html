<!doctype html>
<html lang="th">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Snake Game with Monster</title>
<style>
body {
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  height:100vh;
  margin:0;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color:#fff;
  font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}
#game {
  background:#1a1a2e;
  image-rendering:pixelated;
  border-radius:12px;
  box-shadow: 0 20px 60px rgba(0,0,0,0.4);
}
.ui {
  position:fixed;
  top:20px;
  left:20px;
  background: rgba(255,255,255,0.1);
  padding: 15px 20px;
  border-radius: 12px;
  max-width:280px;
}
.diff-btn.active { background:#4ecdc4; }
.touch-controls-wrapper { position:fixed; bottom:20px; right:20px; }
.touch-btn { width:70px; height:70px; font-size:32px; }
</style>
</head>
<body>

<div class="ui">
Score: <span id="score">0</span><br>
High Score: <span id="highScore">0</span><br><br>

Difficulty:
<button class="diff-btn active" data-level="easy">Easy</button>
<button class="diff-btn" data-level="normal">Normal</button>
<button class="diff-btn" data-level="hard">Hard</button>
<br><br>
<button id="restart">Restart</button>
</div>

<canvas id="game" width="400" height="400"></canvas>

<div class="touch-controls-wrapper">
  <button class="touch-btn" data-dir="up">▲</button><br>
  <button class="touch-btn" data-dir="left">◀</button>
  <button class="touch-btn" data-dir="down">▼</button>
  <button class="touch-btn" data-dir="right">▶</button>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const highScoreEl = document.getElementById('highScore');
const restartBtn = document.getElementById('restart');
const diffBtns = document.querySelectorAll('.diff-btn');
const touchBtns = document.querySelectorAll('.touch-btn');

const GRID = 20;
const COLS = canvas.width / GRID;
const ROWS = canvas.height / GRID;

let snake, dir, food, monster, running, score, tickInterval, monsterMoveCounter;
let difficulty = 'easy';
let freezeItem = null;
let monstersFrozen = false;
let freezeDuration = 0;
let nextFreezeScore = 100;
let highScore = 0;

const difficultySettings = {
  easy:   { snakeSpeed: 100, monsterMoveInterval: 4, monsterCount: 1 },
  normal: { snakeSpeed: 80,  monsterMoveInterval: 3, monsterCount: 1 },
  hard:   { snakeSpeed: 70,  monsterMoveInterval: 2, monsterCount: 2 }
};

diffBtns.forEach(btn => {
  btn.addEventListener('click', () => {
    diffBtns.forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    difficulty = btn.dataset.level;
    resetGame();
  });
});

function resetGame(){
  snake = [{x: Math.floor(COLS/2), y: Math.floor(ROWS/2)}];
  dir = {x:1, y:0};
  placeFood();
  spawnMonsters();
  freezeItem = null;
  monstersFrozen = false;
  freezeDuration = 0;
  score = 0;
  nextFreezeScore = 100;
  scoreEl.textContent = score;
  running = true;
  monsterMoveCounter = 0;
  clearInterval(tickInterval);
  tickInterval = setInterval(gameTick, difficultySettings[difficulty].snakeSpeed);
}

function spawnMonsters(){
  monster = [];
  const count = difficultySettings[difficulty].monsterCount;
  for(let i = 0; i < count; i++){
    monster.push({
      x: Math.floor(Math.random() * COLS),
      y: Math.floor(Math.random() * ROWS)
    });
  }
}

function updateHardMonstersByScore() {
  if (difficulty !== "hard") return;

  let targetCount = 2;
  if (score >= 800) targetCount = 4;
  else if (score >= 400) targetCount = 3;

  while (monster.length < targetCount) {
    monster.push({
      x: Math.floor(Math.random()*COLS),
      y: Math.floor(Math.random()*ROWS)
    });
  }
}

function placeFood(){
  food = { x: Math.floor(Math.random()*COLS), y: Math.floor(Math.random()*ROWS) };
}

function placeFreezeItem(){
  freezeItem = { x: Math.floor(Math.random()*COLS), y: Math.floor(Math.random()*ROWS) };
}

function moveMonsters(){
  if (monstersFrozen) return;
  monster.forEach((m, index) => {
    const head = snake[0];
    let targetX = head.x;
    let targetY = head.y;

    if (difficulty === "hard") {
      if (index === 1) targetX += 2;
      if (index === 2) targetY += 2;
      if (index === 3) { targetX += 3; targetY += 3; }
    }

    const dx = targetX - m.x;
    const dy = targetY - m.y;

    if (Math.abs(dx) > Math.abs(dy)) m.x += dx > 0 ? 1 : -1;
    else m.y += dy > 0 ? 1 : -1;

    m.x = (m.x + COLS) % COLS;
    m.y = (m.y + ROWS) % ROWS;
  });
}

function gameTick(){
  if(!running) return;

  updateHardMonstersByScore();

  const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };
  head.x = (head.x + COLS) % COLS;
  head.y = (head.y + ROWS) % ROWS;

  if (snake.some(s => s.x===head.x && s.y===head.y)) return gameOver();
  if (monster.some(m => m.x===head.x && m.y===head.y)) return gameOver();

  monsterMoveCounter++;
  if(monsterMoveCounter >= difficultySettings[difficulty].monsterMoveInterval){
    moveMonsters();
    monsterMoveCounter = 0;
  }

  snake.unshift(head);

  if (head.x === food.x && head.y === food.y){
    score += 10;
    scoreEl.textContent = score;
    placeFood();

    if(score >= nextFreezeScore && !freezeItem){
      placeFreezeItem();
      nextFreezeScore += 100;
    }
  } else {
    snake.pop();
  }

  if(freezeItem && head.x === freezeItem.x && head.y === freezeItem.y){
    freezeItem = null;
    monstersFrozen = true;
    freezeDuration = 50;
  }

  if(monstersFrozen){
    freezeDuration--;
    if(freezeDuration <= 0){
      monstersFrozen = false;
    }
  }

  draw();
}

function gameOver(){
  running = false;
  if(score > highScore){
    highScore = score;
    highScoreEl.textContent = highScore;
  }
}

function draw(){
  ctx.fillStyle = "#1a1a2e";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  ctx.fillStyle = "#ff6b6b";
  ctx.fillRect(food.x*GRID, food.y*GRID, GRID, GRID);

  if(freezeItem){
    ctx.fillStyle = "#00d4ff";
    ctx.fillRect(freezeItem.x*GRID, freezeItem.y*GRID, GRID, GRID);
  }

  monster.forEach(m => {
    ctx.fillStyle = monstersFrozen ? "#00d4ff" : "#ff0066";
    ctx.fillRect(m.x*GRID, m.y*GRID, GRID, GRID);
  });

  snake.forEach(s => {
    ctx.fillStyle = "#4ecdc4";
    ctx.fillRect(s.x*GRID, s.y*GRID, GRID, GRID);
  });
}

function setDirection(d){
  if (d === 'up'    && dir.y !== 1)  dir = {x:0,y:-1};
  if (d === 'down'  && dir.y !== -1) dir = {x:0,y:1};
  if (d === 'left'  && dir.x !== 1)  dir = {x:-1,y:0};
  if (d === 'right' && dir.x !== -1) dir = {x:1,y:0};
}

window.addEventListener('keydown', e => {
  if(e.key === "ArrowUp") setDirection("up");
  if(e.key === "ArrowDown") setDirection("down");
  if(e.key === "ArrowLeft") setDirection("left");
  if(e.key === "ArrowRight") setDirection("right");
});

touchBtns.forEach(btn => {
  btn.onclick = () => setDirection(btn.dataset.dir);
});

restartBtn.onclick = resetGame;

resetGame();
</script>
</body>
</html>
